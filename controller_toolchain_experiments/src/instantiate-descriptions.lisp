;;; Copyright (c) 2014, Georg Bartels <georg.bartels@cs.uni-bremen.de>
;;; All rights reserved.
;;;
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;;
;;; * Redistributions of source code must retain the above copyright
;;; notice, this list of conditions and the following disclaimer.
;;; * Redistributions in binary form must reproduce the above copyright
;;; notice, this list of conditions and the following disclaimer in the
;;; documentation and/or other materials provided with the distribution.
;;; * Neither the name of the Institute for Artificial Intelligence/
;;; Universitaet Bremen nor the names of its contributors may be used to
;;; endorse or promote products derived from this software without specific
;;; prior written permission.
;;;
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.

(in-package :controller-experiments)

;;;
;;; IDEA DESCRIPTION (Georg): 
;;;   I tried creating a description of low-level controllers which can be
;;;   compiled and started at-runtime. I wanted to have these descriptions
;;;   later generated by a reasoning engine like knowrob. This was a proof
;;;   of concept for me.
;;;
;;;   Example of a single joint-controller (without subscription to joint
;;;   state topic):  
;;;
;;; (let ((descr
;;;         (make-hash-table-description
;;;          :dt 0.01
;;;          :desired-value 2
;;;          :p-controller (make-hash-table-description
;;;                         :class "p-controller"
;;;                         :package "robot-controllers"
;;;                         :system "cl-robot-controllers"
;;;                         :p-gain 1.0)
;;;          :publisher (make-hash-table-description
;;;                      :roslisp-publisher
;;;                      (make-hash-table-description
;;;                       :topic "my_topic"
;;;                       :package "std_msgs-msg"
;;;                       :system "std_msgs-msg"
;;;                       :ros-msg "float64"))
;;;          :let-ordering 
;;;          '(:publisher :dt :p-controller :desired-value)
;;;          :toolchain (make-hash-table-description 
;;;                      :publication
;;;                      '(lambda (data)
;;;                        (funcall publisher data))
;;;                      :control
;;;                      '(lambda (error) 
;;;                        (compute-command p-controller 
;;;                         :error error :dt dt))
;;;                      :calc-error 
;;;                      '(lambda (current-value) 
;;;                        (- desired-value current-value))
;;;                      :msg-conversion
;;;                      (make-hash-table-description
;;;                       :function "from-msg"
;;;                       :package "msg-conversions"
;;;                       :system "ros-msg-conversions")
;;;                      :function-ordering 
;;;                      '(:publication :control :calc-error :msg-conversion)))))
;;;   (read-description descr))
;;;
;;;     Evaluating this yields:
;;;
;;; (let* ((publisher
;;;          (let ((publisher (roslisp:advertise "my_topic" 'STD_MSGS-MSG:FLOAT64)))
;;;            (lambda (data)
;;;              (roslisp:publish 
;;;                publisher
;;;                (ros-msg-conversions::to-msg data 'STD_MSGS-MSG:FLOAT64)))))
;;;        (dt 0.01)
;;;        (p-controller (make-instance 'P-CONTROLLER :p-gain 1.0))
;;;        (desired-value 2))
;;;   (compose (lambda (data) (funcall publisher data))
;;;            (lambda (error) (compute-command p-controller :error error :dt dt))
;;;            (lambda (current-value) (- desired-value current-value))
;;;            ros-msg-conversions::from-msg))
;;;
;;;     The main benefit of this system is that it allows to model the toolchain as a 
;;;     a sequence of function calls. I guess one could use this to have a system
;;;     reason about the equations of the control law behind a controller, assembling
;;;     it, and then ask for compilation at runtime.
;;;
;;;     Drawbacks I see at the time of writting:
;;;       - clumsy and way too verbose syntax
;;;       - still very lispy, i.e. one could directly write LISP code instead
;;;       - I do not see much variation in the low-level controller formulations
;;;         to justify this much flexibility
;;;       - I do not have such a math reasoning at hand, at the moment. Mathematica
;;;         or Wolfram's Language could be a candidate
;;;
;;;     I decided to not further pursue this in the closer future but keep this as a
;;;     reference. Was a nice programming experience. ;) (Bremen, May 2014)
;;;
             
(defun load-system (description)
  (asdf:load-system (to-keyword (find-association-with-error description :system))))

(defun to-symbol (symbol-name package-name)
  (intern (string-upcase symbol-name) (string-upcase package-name)))

(defun to-keyword (symbol-name)
  (to-symbol symbol-name "keyword"))

(defun read-description (descr)
  (cond
    ((numberp descr) descr)
    ((stringp descr) descr)
    ((listp descr) descr)
    ((function-description-p descr) (read-function-description descr))
    ((function-composition-description-p descr) 
     (read-function-composition-description descr))
    ((class-description-p descr) (read-class-description descr))
    ((topic-description-p descr) (read-topic-description descr))
    ((publication-description-p descr) (read-publication-description descr))
    ((let-description-p descr) (read-let-description descr))
))

(defun read-function-composition-description (descr)
  `(compose 
    ,@(mapcar (lambda (fn-symbol)
                (read-description (get-association descr fn-symbol)))
              (get-association-with-error descr :function-ordering))))

(defun read-function-description (descr)
  (let ((function-name (get-association-with-error descr :function))
        (package-name (get-association-with-error descr :package)))
    (when (contains-association-p descr :system)
      (load-system descr))
    (to-symbol function-name package-name)))

(defun read-class-description (descr)
  (labels ((ensure-class-finalized (class-definition)
             (unless (sb-mop:class-finalized-p class-definition)
               (sb-mop:finalize-inheritance class-definition)))
           (get-slot-definitions (class-definition)
             (ensure-class-finalized class-definition)
             (sb-mop:class-slots class-definition))
           (get-slot-symbol (slot-definition)
             (with-slots (sb-pcl::name) slot-definition sb-pcl::name))
           (get-slot-name (slot-definition)
             (symbol-name (get-slot-symbol slot-definition))))
    (load-system descr)
    (let* ((class-name (get-association-with-error descr :class))
           (package-name (get-association-with-error descr :package))
           (class-symbol (to-symbol class-name package-name)))
      `(make-instance 
        ',class-symbol
        ,@(apply #'append 
                 (loop for slot-definition in (get-slot-definitions (find-class class-symbol)) 
                       collect (multiple-value-bind (slot-init-value slot-init-value-p)
                                   (find-association descr (to-keyword (get-slot-name slot-definition)))
                                 (when slot-init-value-p
                                   `(,(to-keyword (get-slot-name slot-definition)) ,(read-description slot-init-value))))))))))

(defun read-topic-description (descr)
  (let ((topic (find-association-with-error descr :topic))
        (package (find-association-with-error descr :package))
        (ros-msg (find-association-with-error descr :ros-msg)))
    (load-system descr)
    (values topic (to-symbol ros-msg package))))

(defun read-publication-description (descr)
  (multiple-value-bind (topic-name msg-type)
      (read-description (get-association-with-error descr :roslisp-publisher))
    `(let ((publisher (roslisp:advertise ,topic-name ',msg-type)))
       (lambda (data)
         (roslisp:publish publisher (msg-conversions::to-msg data ',msg-type))))))

(defun read-let-description (descr)
  (let* ((var-list (get-association-with-error descr :let-ordering))
         (form-keys 
           (remove-if 
            (lambda (key) (or (eql key :let-ordering) (member key var-list)))
            (alexandria:hash-table-keys descr))))
    `(let* ,(mapcar (lambda (let-key) 
                      `(,(read-from-string (symbol-name let-key))
                        ,(read-description (get-association descr let-key)))) var-list)
       ,@(mapcar (lambda (form-key)
                   (read-description (get-association descr form-key)))
                 form-keys))))

(defun function-description-p (descr)
  (contains-association-p descr :function))

(defun function-composition-description-p (descr)
  (contains-association-p descr :function-ordering))

(defun class-description-p (descr)
  (contains-association-p descr :class))

(defun topic-description-p (descr)
  (contains-association-p descr :topic))

(defun publication-description-p (descr)
  (contains-association-p descr :roslisp-publisher))

(defun let-description-p (descr)
  (contains-association-p descr :let-ordering))